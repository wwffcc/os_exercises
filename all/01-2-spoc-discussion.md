# 操作系统概述思考题

## 个人思考题

---

分析你所认识的操作系统（Windows、Linux、FreeBSD、Android、iOS）所具有的独特和共性的功能？
- [x]  
举Windows为例，尽管也有系统调用，但和Unix、Linux大不相同：库调用和实际的系统调用是几乎不对应的，微软定义了一套过程，称为应用编程接口（Win32 API），程序员用这套过程获得操作系统的服务。从Windows95开始的所有Windows版本都（或部分）支持这个接口。由于接口与实际的系统调用不对应，微软保留了随着时间（甚至随着版本到版本）改变实际系统调用的能力，防止使已有的程序失效。Win32 API调用的数量是非常大的，数量有数千个。此外，尽管其中许多确实涉及系统调用，但有一大批Win32 API完全是在用户空间进行，结果，在Windows中，不可能了解哪一个是系统调用（如由内核完成），哪一个只是用户空间中的库调用。而且，Win32 API中有大量的调用，用来管理GUI的一些功能。    而Unix中，系统调用如read和系统调用所使用的库过程如read之间几乎是一一对应的关系，此外，POSIX有大约100个过程调用。
共性的功能：都是为用户程序提供一个更好、更简单、更清晰的计算机模型，管理处理器、主存、磁盘、打印机、键盘、鼠标、显示器、网络接口以及各种其他输入/输出设备。一般都运行在内核态，拥有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。操作系统是作为硬件机器的扩展与抽象，是资源的管理者。
>  

请总结你认为操作系统应该具有的特征有什么？并对其特征进行简要阐述。
- [x]  
进程、存储管理、I/O管理、文件管理和安全，具体阐述如下：
进程：操作系统负责进程的管理。进程本质上是正在执行的一个程序，是容纳运行一个程序所需要所有信息的容器。操作系统利用系统调用实现进程的创建和终止，而合作完成某些作业的相关进程经常需要彼此通信以便同步它们的行为，操作系统需要处理好进程间的通信。在限定的秒数流逝后，操作系统还要负责进程的挂起。
存储管理：现在流行的操作系统都支持多道程序设计，为了避免它们相互干扰（包括操作系统本身），需要有某种保护机制，虽然这种机制必然是硬件形式的，但是它由操作系统掌控。运用虚拟主存的技术，对地址空间和物理空间实施管理。
I/O管理：操作系统有管理各式各样的I/O设备的I/O子系统。
文件管理：隐藏磁盘和其他I/O设备的细节特征，并提供给程序员一个良好、清晰的独立于设备的抽象文件模型。为了提供保存文件的地方，大多数操作系统支持目录的概念。
保护：管理系统的安全性完全依靠操作系统，例如，文件仅供授权用户访问。
>   

请给出你觉得的更准确的操作系统的定义？
- [x]  
为用户程序提供一个更好、更简单、更清晰的计算机模型，管理处理器、主存、磁盘、打印机、键盘、鼠标、显示器、网络接口以及各种其他输入/输出设备。
>   

你希望从操作系统课学到什么知识？
- [x]  
希望从该课学会操作系统对进程、线程的管理，地址空间及关联的内存管理，知道文件系统接口和文件系统的实现，以及输入输出的管理。总之，能够掌握操作系统的基本原理和设计方法。
>   

---

## 小组讨论题

---

目前的台式PC机标准配置和价格？
- [x]  
价格：3000-5000
配置：双核i3处理器  独立显卡显存2G  内存4G 硬盘1T  23寸显示器
> 

你理解的命令行接口和GUI接口具有哪些共性和不同的特征？
- [x]  
共性：都是用户接口程序，处于用户态程序中的最低层次，允许用户运行其他程序，但本身都不是操作系统的一部分。
不同：主要体现在与用户交互的方式不一样。命令行接口以终端作为标准输入和标准输出，而GUI通过图形界面，使得交互更为简单直观。
> 

为什么现在的操作系统基本上用C语言来实现？
- [x]  
C语言是高级语言，同时又保留了操控底层的性质，是命令式的语言。在C中分配的存储空间或者是静态的，或者是程序员明确分配和释放的，通常使用malloc以及free库函数，正是由于后面这个性质，即全部由程序员控制所有的内存而且使用明确的指针，使得C语言对编写操作系统而言非常有吸引力。
>  

为什么没有人用python，java来实现操作系统？
- [x]  
python是脚本语言，解释执行，在运行期间才进行数据类型检查；性能差，缺乏真正的多处理器支持，缺乏商业支持。
java是基于C的，没有显式指针，后台运行垃圾回收机制，负责申请的存储空间管理，但操作系统从一定程度上说实际上是个实时系统，当中断发生时，操作系统可能只有若干微妙去完成特定的操作，否则就会丢失关键的信息，因此在任意时刻启动垃圾回收功能是不可接受的。
>  

请评价用C++来实现操作系统的利弊？
- [x]  
利：继承了C语言的特点，同时C++支持面向对象，更好的模块化操作系统中的各个功能，易于修改、调试。
弊：对程序员要求较高，在内存操作等方面容易出错。如空指针、数组越界、内存泄露都是令操作系统程序员头疼的事。
>  

---

## 开放思考题

---

请评价微内核、单体内核、外核（exo-kernel）架构的操作系统的利弊？
- [x]  
微内核：为了实现高可靠性，将操作系统划分成小的、良好定义的模块，只有其中一个模块即微内核运行在内核态上，其余的模块，由于功能相对弱些，则作为普通用户进程运行。比如由于把每个设备驱动和文件系统作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使得整个系统死机。相反，在单体内核中，由于所有的设备驱动都在内核中，一个有故障的音频驱动会很容易引起对无效地址的引用，从而导致恼人的系统立即停机。
单体内核：全部操作系统在内核态中以单一程序的方式运行，系统中的每个过程可以自由调用其他过程。然而，这些可以不受限制彼此调用的成千个过程，常常导致出现一个笨拙和难于理解的系统。
外核：为虚拟机分配资源，并检查试图使用这些资源的意图，以确保没有机器会使用他人的资源，每个用户层的虚拟机可以运行自己的操作系统，但限制在只能使用已经申请并且获得分配的那部分资源。外核的优点是减少了映像层，并且将多道程序（在外核内）与用户操作系统代码（在用户空间内）加以分离，而且相应负载不重，这是因为外核所做的一切，只是保持多个虚拟机彼此不发生冲突。
>  

请评价用LISP,OCcaml, GO, D，RUST等实现操作系统的利弊？
- [x]  

>  

进程切换的可能实现思路？
- [x]  
操作系统维护一张进程表，记录进程的相关信息。每个进程运行一个时间片后，执行中断，保存进程的信息（由汇编语言实现相关寄存器、状态码、程序计数器等的保存），接着调用一个C过程处理某个特定中断类型剩下的工作。完成有关工作后，大概会使某些进程就绪，接着调用调度程序，决定随后该运行哪个进程。随后把控制转给一段汇编语言代码，为当前的进程装入寄存器值以及内存映像并启动该进程运行。
>  

计算机与终端间通过串口通信的可能实现思路？
- [x]  

>  

为什么微软的Windows没有在手机终端领域取得领先地位？
- [x]  

>  

你认为未来（10年内）的操作系统应该具有什么样的特征和功能？
- [x]  

>  

---
